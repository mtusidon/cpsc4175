# Homework 9
## Joseph Kim

__1. The book depicts an ideal software process as a linear flow, like this:
Requirements ? Analysis ? Design ? Implementation
The book then notes that “software development is considerably different in practice[.]” Which reason
do you think is more important for this difference, human error or changing requirements? Why?__

_Changing requirements is probably more important for this difference. This is because the ideal process is designed to minimize errors and maximize development speed. A client is always allowed to change their requirements, but doing so resets the process, as the software engineer then has to go back to the analysis step._

__2. What do you think that the book means when it says that “the waterfall model, which was first put
forward in 1970, is iterative (but not incremental)?”__

_The modern approach to software development combines both iterative and incremental styles, but the waterfall model in its earliest form was purely iterative._

__3. Using the book’s explanation of stepwise refinement, relate an account from your previous personal
experience when you used this type of development model. This does not have to be software related.
Were you successful in your development? Why or why not?__

_When I went camping, I delegated various general duties to my party. When the roles were all distributed, members would come back to ask questions about the specifics of their role, an example being one setting up camp asking about fire making. This stepwise approach ensured one person wasn't doing all of the work and no one had too many tasks to focus on at once._


__4. Looking at figure 2.4 in the book, you see that the Requirements workflow ceases at some point early
in iteration 3, while the Test workflow runs from the very beginning of iteration 1 and ends at the very
end of iteration 4. Make the case that the Requirements workflow should occur in all iterations. Make
the case that the Test workflow should not begin until iteration 2 at the earliest.__

_The purpose of the requirements phase is to determine what the software is supposed to do. It is the very foundation of any project, as not knowing the requirements definitively will cause wasted development time spent on functions or features that weren't asked for. Testing should not begin until the requirements are fully fleshed out, and at least the first iteration must be devoted almost solely to requirements._


__5. Iterative and Incremental Model The book notes that “each iteration can be viewed as a small but
complete waterfall model.” This is sometimes called the cascade model. Think about your experience
in building your class project. How would you explain the iterative and incremental model to a young
programmer who asked you how it worked. This question calls for a reflection on your experience, not
a textbook answer. (Note that the iterative and incremental model and the spiral model are not the
same thing — in this class we are using the spiral model.)__

_The iterative model revisits steps of the incremental model. The benefit of this approach is so that the many phases of software development are equally important, and being able to go through each step in cycles reaps the benefit of focusing on all of those aspects many times. This would also make development feel faster and more productive, because you'll get something done in each cycle._

__6. The book notes that “[a] critical point regarding the waterfall model is that no phase is complete until
the documentation for that phase has been completed[.]” Do you agree with this statement? If this
statement were true, what changes in your personal process would you make to conform to this dictate?__

_I agree with this statement, as you may have a working product in the end, but without proper records and notes you may find yourself working on something that was already finished. Maintenance of work that was already finished is nearly impossible without proper documentation throughout each phase. Changes I would make in my personal process would be to record and document every bit of work I do._

__7. The book discusses nine process models:__

__(a) Evolution-tree Life-cycle Model__

__(b) Iterative-and-incremental Life-cycle Model__
__(c) Code-and-Fix Life-Cycle Model__

__(d) Waterfall Life-Cycle Model__

__(e) Rapid-Prototyping Life-Cycle Model__

__(f) Open-Source Life-Cycle Model__

__(g) Agile Processes__

__(h) Synchronize-and-Stabilize Life-Cycle Model__

__(i) Spiral Life-Cycle Model__

__Of these seven, which do you think fits most closely with the software development process you think
you would feel comfortable with? What is it about this process that appeals to you?__

_I prefer the evolution tree life cycle model. This is because the process is about "evolving", with most development time spent on maintenance. In theory, this model would be the most adaptive, as it is constantly changing to improve. This process appeals to me as I would rather spend more time on maintenance than development, to get the product out quickly._

__8. This question is semi-optional — I don’t expect you to spend more that 15 minutes answering this,
and I’ll be very lenient in grading this question. Open the paper Recursive Functions of Symbolic
Expressions and Their Computation by Machine, Part I, which is recursive.pdf in the PDF directory
of my Github account. Read Part 2 only, pages 2 to 8. I won’t ask you to study this paper, to do so
would be an onerous assignment in itself. Write a one paragraph appreciation of Part 2. Those of you
who are mathematically inclined may find that this suits your taste. For those of you who aren’t, this
is an essential paper that you should at least have seen, even if you don’t have much patience with the
mathematics.__


