# Homework 8
## Joseph Kim
__1. The book notes that the Unied Process is not "a specific series of steps." It notes that \[i]nstead, the
Unied Process should be viewed as an adaptable methodology." Given this, how should you approach
the content in this chapter that seems to present the Unied Process as a specific series of steps? How
would you approach this chapter if you in fact viewed the Unied Process, not as a process, but simply
as a methodology?__
_I would consider the size and scale of the software to be built, the problem domain, staff size, etc. and adjust around the unified process to follow it within reasonable means, and discard all aspects of it that are inapplicable._

__2. The book states that \[t]he object-oriented paradigm is an iterative-and-incremental methodology."
Do you think that this is a true statement? How is this similar to our class discussions of a spiral
approach to software engineering? Is there any difference between these two views, and if so, what is
the difference?__
_Yes, this is because there are benefits to using both iterative and incremental methodologies. An example being that a certain software may face development incrementally, and then approach maintenance iteratively. The spiral approach is a sequence of waterfall increments, which effectively makes it both iterative and incremental. There is a difference, as the incremental approach has separate phases for each part of development, and the iterative approach is basically cycles of incremental development._

__3. In class, we are using an iterative process with four phases: analysis, design, implementation, and
testing. The book discusses the ve core work
ows of the Unied Process. List the ve core work
ows,
and for each, give a brief summary of the workfl
ow.__

_Requirements:
Building the use case model, determining capabilities and conditions software must meet.
Analysis:
Refining the requirements, structuring the functional requirements withing use case model.
Design:
Models of the use case models are produced, using the data acquired from the previous workflows.
Implementation:
Elements of the design model are written as software, packaged.
Testing:
Building a test model, executable parts of the software are run through the use cases._


__4. What is the relationship between the software project management plan and the software development
process? Do you think that a software project management plan can replace an explicit software
development process? Why or why not?__

_The software project management plan organizes and records the progress of the software development process. The management plan cannot outright replace the process, as its intended use is to summarize the process, not actually define it._

__5. Section 3.7 discusses testing with regard to four process areas: requirements artifacts, analysis artifacts, design artifacts, and implementation artifacts. What is the difference between the test workflow discussed in the chapter, and the testing of the artifacts produced in each of the ve process areas? Do you think that this is an inconsistency in the book's treatment of testing?__
_The test workflow itself involves testing of the software as it is being written, while the testing artifacts breakdown this testing for each parallel workflow. I do not think this is an inconsistency, as testing is supposed to happen through out the whole development process.
_

__6. If it is true, as the book claims, that \[p]ostdelivery maintenance is not an activity grudgingly carried
out after the product has been delivered and installed on the client's computer," how do you t
postdelivery maintenance into an iterative, spiral development model?__
_Postdelivery maintenance can itself have its own development model, meaning the requirements can be revised to fit changing client needs or fault fixing. Then the workflows are carried out just like they were in development._

__7. Look at gure 3.10 on page 88 of the book. This gure seems to suggest a model of ve work
ows
(requirements, analysis, design, implementation, and testing), with each work
ow consisting of four
phases (inception, elaboration, construction, and transition). In class, we have talked about an itera-
tive, spiral model with four phases for each iteration (analysis, design, implementation, and testing).
Do you think that these two approaches are mutually exclusive? Do you think that they are mutually
supportive? Before you answer, review your response to the rst question.__
_They are mutually supportive, because the unified workflow is supposed to work as an adaptive methodology; the purpose of the 4 phases is to refine the specifics of the unified workflow. As it is adaptive, these phases can be shortened or lengthened to adapt to the software actually being made._

__8. Look at figure 3.2 on page 94. In a sense, the waterfall method can be easily adopted to an iterative,
spiral development model, using the waterfall approach to model each iteration, i.e., not a \waterfall"
but a series of rapids, or a cascade. Viewed in this way, how do you think model 3.2a and 3.2b would
actually dier in a real-life project? Do you think that they would basically amount to the same thing,
or do you think that they would be fundamentally dierent?__
_I think it would differ as figure 3.2 seems to be meant for a more static development rather than a spiral model of rapids. There are clearly defined phases that may not be meant to repeated.
_

__9. The last section discusses software process improvement. What is the dierence between software im-
provement, and software process improvement? How important do you think that software process
improvement is in the eld of software engineering?__
_Process improvement is focusing on improving the development model of the software, while software improvement is simply maintenance. I think process improvement is very important in software engineering, as there are unforeseen changes that are bound to happen as more technology and paradigms is researched and implemented. This would fit into having an adaptive model._